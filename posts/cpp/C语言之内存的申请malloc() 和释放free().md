```
{
    "url": "c-malloc-free",
    "time": "2015/04/23 10:30",
    "tag": "C",
    "toc": "no"
}
```

# 1、如何使用 malloc 函数

malloc是一个函数，专门用来从堆上分配内存。使用malloc函数需要几个要求：

- 内存分配给谁?
- 分配多大内存?
- 是否还有足够内存分配?
- 内存的将用来存储什么格式的数据，即内存用来做什么?
- 分配好的内存在哪里?

如果这五点都确定，那内存就能分配。下面先看malloc函数的原型：
```
(void *)malloc(int size)
```
看到了没有，这里的返回类型是(void *)，这是多巧妙的一个设计啊。

malloc函数的返回值是一个void类型的指针，参数为int类型数据，即申请分配的内存大小，单位是byte。内存分配成功之后，malloc函数返回这块内存的首地址。你需要一个指针来接收这个地址。但是由于函数的返回值是void *类型的，所以必须强制转换成你所接收的类型。也就是说，这块内存将要用来存储什么类型的数据。比如：
```
char *p = (char *)malloc(100);
```
在堆上分配了100个字节内存，返回这块内存的首地址，把地址强制转换成char *类型后赋给char *类型的指针变量p。同时告诉我们这块内存将用来存储char类型的数据。也就是说你只能通过指针变量p来操作这块内存。这块内存本身并没有名字，对它的访问是匿名访问。

上面就是使用malloc函数成功分配一块内存的过程。但是，每次你都能分配成功吗？

不一定。

函数同样要注意这点：如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回NULL。注意这里说的"堆上剩余内存块"不是所有剩余内存块之和，因为malloc函数申请的是连续的一块内存。既然malloc函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用if（NULL！=p）语句来验证内存确实分配成功了。

# 2、 用 malloc 函数申请 0 字节内存

另外还有一个问题：用malloc函数申请0字节内存会返回NULL指针吗？
可以测试一下，也可以去查找关于malloc函数的说明文档。申请0字节内存，函数并不返回NULL，而是返回一个正常的内存地址。但是你却无法使用这块大小为0的内存。这好尺子上的某个刻度，刻度本身并没有长度，只有某两个刻度一起才能量出长度。对于这一点一定要小心，因为这时候if（NULL！=p）语句校验将不起作用。

# 3、内存释放

既然有分配，那就必须有释放。不然的话，有限的内存总会用光，而没有释放的内存却在空闲。与malloc对应的就是free函数了。free函数只有一个参数，就是所要释放的内存块的首地址。比如上例：`free(p);`

free函数看上去挺狠的，但它到底作了什么呢？

其实它就做了一件事：斩断指针变量与这块内存的关系。

比如上面的例子，我们可以说malloc函数分配的内存块是属于p的，因为我们对这块内存的访问都需要通过p来进行。free函数就是把这块内存和p之间的所有关系斩断。从此p和那块内存之间再无瓜葛。至于指针变量p本身保存的地址并没有改变，但是它对这个地址处的那块内存却已经没有所有权了。那块被释放的内存里面保存的值也没有改变，只是再也没有办法使用了。

这就是free函数的功能。按照上面的分析，如果对p连续两次以上使用free函数，肯定会发生错误。因为第一使用free函数时，p所属的内存已经被释放，第二次使用时已经无内存可释放了。关于这点，我(陈正冲老师)上课时让学生记住的是：一定要一夫一妻制，不然肯定出错。

malloc两次只free一次会内存泄漏；malloc一次free两次肯定会出错。也就是说，在程序中malloc的使用次数一定要和free相等，否则必有错误。这种错误主要发生在循环使用malloc函数时，往往把malloc和free次数弄错了。

# 4、内存释放之后

既然使用free函数之后指针变量p本身保存的地址并没有改变，那我们就需要重新把p的值变为NULL：`p = NULL;`

这个NULL就是我们前面所说的"栓野狗的链子"。如果你不栓起来迟早会出问题的。比如：

在free（p）之后，你用if（NULL！=p）这样的校验语句还能起作用吗？
例如：
```
char *p = (char *) malloc(100);
strcpy(p, "hello");
free(p); /* p 所指的内存被释放，但是p所指的地址仍然不变*/
...
if (NULL != p)
{
    /* 没有起到防错作用*/
    strcpy(p, "world"); /* 出错*/
}
```
释放完块内存之后，没有把指针置NULL，这个指针就成为了“野指针”，也有书叫“悬垂指针”。这是很危险的，而且也是经常出错的地方。所以一定要记住一条：free完之后，一定要给指针置NULL。

# 5、内存已经被释放了，但是继续通过指针来使用

这里一般有三种情况：

- 第一种：就是上面所说的，free（p）之后，继续通过p指针来访问内存。解决的办法就是给p置NULL。
- 第二种：函数返回栈内存。这是初学者最容易犯的错误。比如在函数内部定义了一个数组，却用return语句返回指向该数组的指针。解决的办法就是弄明白栈上变量的生命周期。
- 第三种：内存使用太复杂，弄不清到底哪块内存被释放，哪块没有被释放。解决的办法是重新设计程序，改善对象之间的调用关系。